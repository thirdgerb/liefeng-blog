---
title: "对话OS的前景与复杂多轮对话的关键功能点"
date: 2019-08-19T12:44:20+08:00
draft: false
tags: ["commune", "chatbot"]
series: ["commune开发笔记"]
categories: ["开发记录"]
img: ""
toc: true
summary: "作者认为多轮对话机器人的未来不仅在于拟人的智能客服, 更能发展成为语音操作系统, 与其它交互一起引领下一轮智能设备的交互革命. 从这个角度看, 图灵测试的标准并非必须, 反而复杂多轮对话管理是目前的短板. 与机器学习实现多轮对话的方案相比, 工程化的思路也具备许多相对优势."
---

本文作者基于个人兴趣开发了一个工程化的多轮对话机器人框架([CommuneChatbot](https://github.com/thirdgerb/chatbot)). 这篇文章用来记录自己对多轮对话机器人问题的部分认识和思考.

由于见识有限, 仅供参考, 欢迎批评指教.

本文将讨论以下三个问题:

-   ```对话OS```(主要基于语音的操作系统)是对话机器人的未来方向之一, 或将领衔下一轮的交互革命
-   ```复杂多轮对话```问题是现阶段对话机器人短板, 关键在于定义哪些功能点 ( features )
-   从```对话OS```角度看, 并非只有机器学习一条路, 工程化策略也有许多相对优势


##  认识复杂多轮对话交互


###  从交互角度看对话机器人

对话机器人在NLP技术推动下, 这几年又火了起来, 最火的领域是在线客服和智能音箱.
可能在许多人心里, 对话机器人的重点在于```对话```, 类似小冰这种. 许多人似乎认为通过图灵测试是对话机器人最大的指标.

而我一直把```对话``` 理解成一种```交互方式```. 重点在于交互.

```对话机器人```在```交互```的思路中, 相当于一个```界面(interface)```, 和屏幕+键盘, 图形界面, 触屏等在本质上是一致的.

在这种思路中, 看重的并不是能否纯自然语言对话, 能否通过图灵测试; 而是它能不能快速帮用户命中意图, 从而操作服务端, 智能设备, 物联网设备来解决问题.

也可以把这个方向的对话机器人直接定义为```对话OS``` (对话形式的操作系统).

### 对话OS可能带来一场交互革命

我们接触的设备, 最早的OS(操作系统) 可能是 仪表盘+按钮+阀门,
目前已经成了一种怀旧的审美风格(蒸汽朋克)

个人电脑的诞生, 除了硬件技术的革命外, 屏幕+键盘 的交互形式也是必要条件.

图形化+鼠标带来的交互革命, 已经统治了个人电脑几十年, 催生了微软和苹果两个帝国.

由iphone代表的触屏交互, 则带来了移动互联网的黄金十年, 我们目前正生活在这个时代.

马上就要来临的下一个交互时代, 我认为会是多种模式的. 语音, 动作, 视觉追踪都会扮演重要角色;
而语音交互将会是最先成熟的交互形式.


---

回想 屏幕+键盘 把计算机带到了个人的家中. 而触屏交互最大的意义, 在于```空间上解放了人```.

电脑的昂贵不在于显卡或cpu, 而在于你要拥有独立的空间, 比如在北京这样的城市有自己独居的卧室,
才能摆放它. 而触屏交互, 让我们在被窝里, 在马桶上, 在马路牙子上, 在餐桌旁, 在地铁里... 都能使用智能设备和互联网. 它在降低成本的同时, 也带来了生产力的革命.


所以我才看好对话机器人. 因为它能把语音交互发展成 OS. 从而在```姿势上解放了人```.

我们不需要低头眼睛盯着屏幕, 僵硬着双肩握着触屏了.
这意味着可以在骑车, 走路, 跑步, 做饭, 开车, 开会演讲等各种行动姿态下使用智能设备.

而且```语音OS``` 比基于视觉的OS还有一个直接的优势, 语义是可以直达意图的, 而不需要通过层层嵌套的页面点击进自己需要的功能.

因此 "手机" 作为智能设备的躯壳, 如同 "个人电脑" 作为智能设备的躯壳一样, 都变得不重要了.
我想象未来以语音作为OS主体的智能设备, 会完全解体, 分散到智能穿戴, 物联网设备和云端上.
于是带来软件和硬件的双重革命, 在解放生产力的同时也带来一个类似移动互联网式的数十年繁荣.

###  足够 "聪明" 的NLP技术并非 "对话OS" 所必要

之前交流, 有许多朋友认为对话机器人的 "聪明" 与否, 就看 NLU 语义理解是否准确. 我对此持不同看法, 事实上对话机器人有四个模块:

-   输入转换, 例如语音转文字
-   输出合成, 例如文字转语音
-   语义识别, 包括意图, 实体提取等
-   多轮对话管理

哪一个模块不够 "聪明", 整个机器人都会显得不聪明.

现阶段多轮对话机器人已经很火, 比如智能客服和智能音箱. 但以"OS"的标准来看还不够成熟.

事实上现在语音识别, 语音合成, 语义识别的能力都已经做到生产环境可用了.
虽然离图灵测试标准虽然有差距, 但 "对话OS" 也许并不需要成熟的图灵机器人.

试想 windows, office, mac 这些非常成熟, 交互非常贴近人理解的软件, 也都有教程和说明书.
而程序员熟悉的 shell, 更是不看说明文档寸步难行.
连电影《钢铁侠》《蜘蛛侠》里都会拿语义理解错误导致的 "人工智障" 开玩笑 (蜘蛛侠给AI "星期五" 下命令, 理解成杀死同学 ).
为何 "对话OS" 必须要往图灵测试方向走, 要去无限响应用户的表达呢?

我认为 ```对话OS``` 现阶段需要的不是五岁小孩也能符合预期地操作它, 而是在给定范围内能准确执行用户的意图.
对边界意图的识别也许技术上很耀眼 (例如能理解"以前喜欢一个人, 现在喜欢一个人"), 但并非关键, 其实人类自己会学习最好的表达方式去和OS交互, 因为目的明确时, 为的就是最高效地操作设备.

### "多轮对话管理" 或是 "对话OS" 目前的短板

所以用 "对话OS" 的需求来看, 我觉得对话机器人目前最大的短板反而是 "多轮对话管理".

先介绍一下 "多轮对话" 的含义. 首先看什么是 "单轮对话"

    用户: 你好!
    机器人: 你好呀  // 一轮对话

    用户: 北京今天什么天气?
    机器人: 北京今天晴天, 气温29度, 注意防晒 // 上下文无关的另一轮对话

如果用户一个意图需要多次单轮对话组成, 那就是 "一阶多轮对话" :

    用户: 北京今天什么天气?
    机器人: 北京今天晴天, 气温29度, 注意防晒
    用户: 后天呢?
    机器人: 北京后天多云, 气温30度 // 时间改变, 地点没改变, 需要上下文记忆
    用户: 那上海呢?
    机器人: 上海后天晴天, 气温28度 // 地点改变, 时间没改变, 需要上下文记忆

而真正的自然语言对话, 不是 "一阶" 的, 而是 "n阶" 多轮对话相互嵌套, 构成一种分形结构

    用户: 你好!
    机器人: 您好, 请问有什么能帮您的? // 入口, 澄清需求

        用户: 我想订一份午餐 // 进入点购外卖的需求
            机器人: 好的, 这是我们的菜单 ... 请问您需要什么 // 进入选择环节

                用户: 来一份大盘鸡吧
                机器人: 好的. 请问要什么辣度, 我们有不辣, 微辣, 中辣 // 相当于填写表单
                ... // 多轮确认

            机器人: 您已点了大盘鸡, 还需要什么吗?
            用户: 再来一个凉菜的拼盘吧 // 进入另一个点菜环节

                机器人: 好的, 我们这儿有 .... 您可以任选五种 // 继续填表单
                用户: 随便吧 // 跳过填写流程
                机器人: 好的, 我给您选了 .... 您看是否可以 // 确认环节
                用户: 行

            用户: 再来一个辣椒炒肉
            机器人: ...
            用户: 等等, 这个菜我不要了, 换一个 // 跳出当前多轮对话
            ... // 继续点其它菜品

            用户: 这些菜就够了 // 结束点菜环节

            机器人: 好的. 总共是 201 块钱, 订单是... 您看对吗? // 订单确认
            用户: ok

            机器人: 您上次的送餐地址是 ... , 这次还是这里吗? // 确认地址
                用户: 不是, 这次地址是 .... // 进入确认地址的对话
                ...

            机器人: 好的, 请您支付, 这是支付的链接 // 进入付款环节
            用户: 支付中...

            机器人: 您的订单 ... 已经开始制作. // 任务挂起.

    机器人: 请问我还能为您做些什么 ? // 回到澄清需求
    用户: 正好有个事情我要问你一下 ... // 进入新的需求
        ... // 执行新的需求

        机器人: 对了, 您的餐品刚才已经发出, 大概 20分钟后快递员会给您送到 // 挂起任务苏醒+通知
        用户: 好的.

        机器人: 那我们继续回到刚才的话题, ... // 任务调度, 还原挂起任务

    用户: 我没有别的事情了.
    机器人: 好的, 谢谢您的光临, 下次再见! // 结束会话.


这是一个```N阶多轮对话```的例子. 多个```1阶多轮对话```相互嵌套, 带来了一系列```1阶多轮对话```不存在的技术问题, 例如: ```语境的嵌套, 导航, 跳转, 隔离, 脱出, 意图域的隔离, 上下文记忆, 多任务调度, 任务挂起, 任务唤醒```等等...

而目前的 NLP 对话机器人, 大多通过 "词槽" 等方式实现上下文记忆和多轮对话, 本质上多是 "1阶多轮对话".
或者允许从一个多轮对话, 跳到另一个多轮对话, 但不构成嵌套的话, 其实仍然是1阶, 或许可以称之为1.5阶.

如果我们把抽象提高一层, ```多轮对话``` 的本质是 ```多轮交互```.
可以看到, 已经成熟的各种OS, 例如 "桌面软件", "浏览器", "触屏", 都能完整地实现无限步数, 复杂嵌套的"N阶多轮交互" .
但对话机器人目前还没走到这一步. 这意味着对话机器人, 还开发不出类似 app 和网站那样成熟的应用.

所以我反而觉得```复杂多轮对话```才是```对话OS```目前的短板所在.



### "工程化" 策略对 "对话OS" 是可行的


对话机器人的实现, 目前有两种思路.

一种是过去延续下来的, ```工程化```(规则化)的思路, 靠写代码, 进一步写配置, 来定义对话流程; 另一种则是从海量语料中通过机器学习等方法```训练```机器人.

前者更适合冷启动开发功能, 但和app, web开发一样要堆人力.
而后者在语料大数据前提下, 或能足够廉价地训练出拟人的机器人.


由于对话机器人这几年的繁荣是 NLP 技术发展推动的.
所以现阶段我看到的对话机器人, 大多都是按 "拟人" 的标准来定义功能的.
它们对标人工客服, 语音电销等, 目的是取代人工.

而那些不言明身份的智能客服, 本质上就是一个大规模图灵测试.


但据我上文的理解, NLP 技术现在达不到图灵测试的要求, 而且也并非 "对话OS" 所必须.
完全按 "图灵测试" 的标准来设计 "对话OS" , 我觉得没有必要.


如果对标其它的```交互OS```, 比如桌面软件, 浏览器网站, app应用, 目前都是由```工程化```在主导.
从这个角度来看, ```对话OS``` 目前在```多轮对话```的领域, 可以走 "工程化优先" 的路.
快速用工程开发应用, 冷启动, 快速迭代. 积累足够多语料后, 再通过 NLP 技术赋予用户更贴近自然习惯的多轮对话管理.


而这一个方向只有一个很小很小的门槛没跨过: 不是按```拟人```的标准定义多轮对话的功能点, 而是按```对话OS```的标准去定义.

一旦功能点 (features) 被定义出来; 对话机器人就像软件, 网站, 浏览器一样, 很快就能被工程师研发出来.


以上的思考, 正是我开发 CommuneChatbot 项目的初衷.

##  复杂多轮对话机器人的功能点


CommuneChatbot 项目的自我定位是一个```工程化的复杂多轮对话机器人框架```.

它的许多工程上的技术细节, 是资深的服务端工程师都能做到的, 许多点别人能比我做得更好. 而最大的心血其实不是如何工程上实现, 而是如何定义```复杂多轮对话的功能点```(features).

许多人当面表示这个事情很容易吧. 但实话实说, 本人把 18年大多数可工作的业余时间, 都用来思考这个项目, 才得到了一套解决方案.

主要做了三类思考:

-   对自然对话的各种现象进行分析, ```抽象出多轮对话功能点```
-   ```设计, 创建多轮对话模型```以实现这些抽象化的功能点
-   设计工程方案, 在```分布式服务端```实现这个多轮对话模型

先不说成品是否存在各种问题, 但这个设计的过程, 并没有找到任何一个可以直接借鉴的对象. 我调研的开源项目 [hubot](https://hubot.github.com/) , [botkit](https://www.botkit.ai/), [botman](https://botman.io/) 都有一定多轮对话的能力, 但在```n阶多轮对话``` 问题上是不足的.

以他们工程师的水平来看, 工程实现的能力非常强大. 之所以没有实现我关心的功能点, 也许因为它们已满足目前生产环境的需求. 尚未让他们提出其它 features.

如果对标的是拥有```成熟多轮交互```能力的其它OS(比如浏览器等), 我认为下面的 features 是必不可少的:

-   语境嵌套, 跳转与隔离
-   流程分支, IO, 跳转, 导航, 与脱出
-   语境过滤与回归
-   有作用域的上下文记忆
-   任务暂停, 挂起与唤醒


### 语境嵌套, 跳转与隔离

我们的每一轮对话都发生在一个具体的上下文中. 同样的话语, 在不同上下文中的理解和反馈是截然不同的.

这需要对上下文进行建模, 构成```语境```的存在.
从```交互OS```的角度来看, ```语境```非常好理解. 例如把```浏览器```当成一种OS.
每一个 ```URL 对应的页面```, 就是一个独立的```语境```.

在不同的页面上, 可进行的操作完全不同. 因此```浏览器语境```是相互```隔离```的.

一个页面只允许通过页面内的链接, 跳到指定的另一批页面, 所以```跳转```的逻辑是受约束的.

浏览器上未登录用户会先跳到登陆页, 登录完再跳回来. 各种功能都与此类似, 是由多个页面在逻辑上相互嵌套, 然后构成一个完整的```多轮交互```. 这种嵌套原则上是分形的, 允许无限嵌套, 所以是```n阶多轮交互```.

这些功能点, 只实现到```1阶多轮交互```的对话机器人就暂时不具备. 常见的问题有:

-   依赖唤醒词: 通过唤醒词强行中断, 开启另一个多轮对话来做跳转, 而不是嵌套.
-   完全开放域: 机器人永远都在匹配 N种 意图, 不会在一个语境匹配 N种, 另一个匹配 M 种
-   完全封闭域: 进入多轮对话, 流程尚未结束时, 完全不能匹配其它意图
-   无法组件式复用: 例如两组对话都要求 "录入家庭信息", 但流程各自都要重新定义一遍.


其实对```网页多轮交互```的建模经验, 同样可以借鉴到```对话多轮交互```的建模任务中. 不过和浏览器, 桌面软件不同; 人类对话的```语境```不存在于```视觉```中, 而存在于```记忆```中. 我分析记忆里的上下文包含以下方面:

-   当前对话的目的
-   需要记忆的参数
-   对输入和输出的管理 (IO)
-   执行各种逻辑
-   之前对话的轨迹

对程序员而言, 这种```上下文```的定义和```程序语言```本身是一回事. ```语境```就像```function``` 或者 ```object```; 而多个语境的嵌套, 跳转, 和多个```function```嵌套构成的```stack```本质上是一回事 (也会因循环重定向导致overflow).

因此, 我认为就```对话OS```而言, 自然语言的 ```多轮对话交互``` 本身也能用```图灵完备```的标准设计出来. 用程序语言同样的工程思路来定义人类的```n阶多轮对话```.


CommuneChatbot 的解决方案中, 多轮对话内核叫做```OOHost```, 采用的是```面向对象```的工程思路. 它把每一个```上下文语境```定义为一个名为```Context```的对象.

通过```Context``` 组织成的上下文流程, 在 CommuneChatbot 中又分为:

-   process : 会话级别的上下文
-   thread : 当前任务级别的上下文
-   task : 子任务, 组件级别的上下文
-   stage : 流程级别的上下文

stage 级别的语境是最底层的. 由它来定义能够做的上下文理解, 从而实现隔离. 所有的语境单位在工程上都是组件化的, 可以复用.

类似网页的url跳转, 上下文语境互相之间也有各种复杂的跳转关系. CommuneChatbot 的模型里定义了一部分, 例如 :

-   路径导航
    -   backward
    -   forward
-   跳转 ( redirect )
    -   goStage
    -   sleepTo
    -   replaceTo
    -   yieldTo
    -   dependOn
-   回归 ( callback )
    -   next
    -   fullfill
-   脱出 ( exiting )
    -   cancel
    -   reject
    -   fail
-   拦截事件
    -   callback
    -   onWake
    -   onCancel
    -   onReject
    -   onFail


这些流程产生的路径会形成类似栈的数据结构, 存储在分布式一致性的介质里. 通过下一轮对话得以在 session 中还原.


这种建模相当于用现成的面向对象语言模拟出另一个面向对象语言, 用后者来设计复杂多轮对话.
除了工程可读性上要做很多设计之外, 唯一的难度在于后者是在分布式服务器集群中实现, 而不是在内存中;
所以建模需要考虑数据的分布式一致性, 数据体积, 序列化存储, 还原等等.


### 流程分支, 循环, IO, 跳转, 导航, 与脱出

用```编程语言```的思路来看待多轮对话的建模, 一些关键的 features 就不言自明了.
让我们看看编程语言最常见的特性:

-   分支: if...else... , 然后走不同的分支
-   循环: for, while 等, 实现逻辑的 loop 与 break
-   IO: 遇到IO时需要程序挂起, 等待用户输入. 在对话中则是等待回复. 每一步都可校验
-   跳转: function 的嵌套, 参数的传递, return后回到的位置. 通过 stack 实现
-   导航: 因用户输入暂时跳出当前流程, 进入另一个流程. 类似 goto
-   脱出: 中断当前流程, 类似 try catch exception

这些特性在人类自然语言的多轮对话中是同样存在的, 编程语言本来就是对自然语言的模拟.

但目前的多轮对话机器人不一定实现了所有的features, 所以可以看到些一些现象:

-   不能单步校验输入, 需要 N 个输入完成后统一校验
-   循环对话需要指定次数, 无法动态编程, 或不能break
-   无法实现组件化的多轮对话, 每个复用的逻辑都要在定义对话时重写一次
-   无法中断, 跳过流程(例如买东西告知属性时, 用户说"随便")
-   从一个语境到另一个语境, 前面的语境就消失了
-   在N阶多轮对话中, 出错或用户退出, 就直接退出所有语境. 只有统一的退出提示.

更重要的一点是, 完全基于机器学习打造的多轮对话机器人 (把多轮对话上下文序列化, 作为机器学习的输入), 除非语料足够丰富满足各种对话分枝的要求, 否则很难启动时就具备完整的路径规划.

在高度组件化的前提下, 用工程的手法开发一个新的多轮对话, 类似开发app 和网站, 程序员几个小时就能完成, 甚至可以按 TDD 思路设计自动化测试 (在多轮对话中录制多轮对话以测试多轮对话).

而几个小时的时间, 可能还不足以让机器学习完成一次神经网络的训练, 不用说测试了.

所以我认为, 用```图灵完备``` 的工程化对话机器人开发多轮对话, 比机器学习开发起来还能更高效; 而前者能够冷启动为后者积累语料; 两种策略都需要在生产环境中反复迭代打磨才能变得优秀, 完全可以用某种策略来使两者很好地配合.

### 语境过滤与回归

这儿定义的```语境过滤与回归```比 if...else... 的情况要更复杂.

简单来说, 当对话由 A 语境进入到 B 语境之后, 只有 A 语境不能解决的对话才交给 B 语境, 我称之为```语境过滤``` .

对话由 A 语境进入到 B 语境之后, B 语境解决不了的对话会重新交给 A 语境来解决, 我称之为 ```语境回归``` .

如果类比 ```浏览器交互``` 的话, 这种 A 和 B 语境的关系, 类似浏览器自带菜单和展示页面的关系. 无论当前页面是哪一个, 点击浏览器上的 "前进", "后退", "关闭" 或是点击 "收藏夹" 都比点击页面的优先级更高.

之所以存在 "过滤" 与 "回归" 的问题, 因为```视觉交互```可以在 N 个目的中精准地定位到其中一个. 而```语言交互``` 则必须按优先级筛选所有 N 个可能性. 匹配到的意图, 在不同的语境中有截然不同的含义. 这样 ```过滤``` 与 ```回归``` 的优先级应该要能体现多重语境的嵌套.

工程化的解决思路其实很成熟, 就是把语境的嵌套做成一个洋葱的形状. 输入从外层进入, 层层往里; 然后从内层输出结果, 层层往外. 每一层都对输入拦截一次, 再对输出拦截一次, 构成一个洋葱式的管道.

在 CommuneChatbot 中, 则是可以从一个包含上下文的 Session A 中新开一个 Session B, 只有Session A 不拦截的输入才交给 Session B, 而 Session A 要解决 Session B 无法响应的输入.

类似这样的工程需求, 我目前都想不到如何保证机器学习的对话机器人能准确实现.

### 有作用域的上下文记忆

既然有上下文, 就一定有记忆. 常见的多轮对话机器人有两种记忆模式, 一种是 "1阶多轮对话" 本身的记忆, 通常用 ```填槽``` (slots) 的方式实现. 在对话未完成时, "slots" 的值是跟着走的.

如果两个 "1阶多轮对话" 要共享记忆, 常见的做法就不是由多轮对话内核去管理, 而是业务方自己在api里存储. 自己定义一套全局的记忆模块, 无论基于数据表或缓存.

如果用```编程语言```的角度来看, 上下文记忆无非是三种情况:

-   局部变量
-   外部变量
-   全局变量

程序员对这种抽象就很容易理解了. 随着语境的需要, 我们要能通过:

-   参数传递, 获取局部变量
-   获取外部域变量
-   获取静态变量

的方式获取各种上下文记忆.

CommuneChatbot 中我自认为设计了一种巧妙的办法, 将上下文记忆和多轮对话的生命周期结合了起来.
框架里所有的上下文, 都作为一个```context``` 对象, 并在分布式服务端集群里用唯一ID存储到了缓存或数据表中.

只要生成```唯一ID本身对作用域敏感```, 就能按作用域任意生成相互隔离和共通的记忆了. 我设计了许多个作用域的维度:

-   userId
-   chatId
-   messageId
-   SessionId
-   Date: y m d h i
-   等等...

在定义 ```Memory对象``` ( 也是Context 的一种 ) 时, 需要从这 N 个维度中挑选 M 个维度, 会用这些维度的值生成一个唯一的ID. 当下一次请求获取 Memory 时, 如果 M 个维度一致, 就能通过同样的 ID 取出上次的记忆.

从而用工程化的方式, 在多轮对话内核中, 实现灵活的按作用域隔离的上下文记忆.

### 任务暂停, 挂起与唤醒

```编程语言``` 中有很重要的一块, 是程序逻辑的调度. 常见的有:

-   进程调度
-   线程调度
-   协程调度

多半通过操作系统内核实现, 而协程是语言用户态自己实现.

这种抽象的现象, 也是符合人类自然语言的规律的. 举一个例子:

    用户: 您好, 我想要办理XXX业务.
    机器人: 好的, 您需要先告诉我您的身份证号码

    用户: 稍等, 我想问一下, 您可以办理YYY业务吗? // 任务中断, 进入另一个任务
    机器人: 可以的, 只需要...

    用户: 好的 // 另一个任务完成.
    机器人: 那请您继续告诉我您的身份证号码 // 唤醒当前任务, 话术有变化

    ...

    机器人: 您的身份证提交去查验了. 2分钟后告诉您结果. 请问您还有什么需要吗? // 任务挂起
    用户: 有的, 我还需要...
    机器人: 可以, 您要... // 开始新的对话
    ...
    用户: 哦, 那我还需要干什么 // 新对话进行中

    机器人: 稍等, 您的身份证查验结束了, 结果是 .... // 挂起任务唤醒, 抢占对话
    机器人: 您还需要下一步修改吗?
    用户: 不用了 // 结束唤醒的对话.

    机器人: 好的. 您刚才的问题是 "那我还需要干什么", 您还需要... // 退回当前任务


类似这样, 涉及到延时, 异步通知等需求, 是常见的多任务调度内容. 这个 feature 对智能助理是必要条件之一.

用工程化的手段来实现, 无非是在分布式服务端中模拟操作系统的任务调度.
要用机器学习来实现的话, 我想工程复杂度反而会消耗掉自主学习的优势.

在 CommuneChatbot 中定义了三个 feature 来实现任务调度:

-   replace
-   sleep & wake
-   yield to service & service callback

由于目前还没有明确生产环境的检验, 所以仅供参考.


### 其它工程化的好处

目前的对话机器人, 往往对话管理模块在机器人一方 (机器学习实现为主), 而业务 api 在业务方, 两者在物理上是分离的.
因此要通过 api 接口传递完整的上下文, 要处理大量的信息.

用工程化的思路兼容多轮对话管理, 则上下文可以把大部分内容转移到业务方. 业务方可以在自己的项目中实现各种便捷的工程手段, 例如:

-   离线开发对话机器人
-   本地测试流程
-   单步逻辑可校验
-   让多轮对话流程在代码里可读 (阅读代码能理解流程)
-   IoC 容器基于依赖注入来管理服务
-   围绕对话生命周期建立自己的监控体系
-   组件化地管理 "1阶多轮对话"
-   根据业务需求, 自己开发配置化的策略, 方便非程序员管理
-   使用分布式配置中心, 在线控制多轮对话逻辑 (比如开启和关闭折扣商品引导)
-   等等...

这些工程便利, 在传统的 app 和 web网站 的开发中很常见. 但在多轮对话机器人中还很少看到. 对话管理在云端和业务方的分离也带来了许多额外的工作量.

使用机器学习打造的对话机器人, 一个很小的逻辑调整都可能要重新整理语料, 重新训练. 因此工程化的机器人在这些方面应该是具备优势的.


## 后话


### 写文本的动机

关于复杂多轮对话机器人的功能点, 之前本想拆开来写一个系列文章, 方便人看. 现在感觉思路太散不好延续,
还是用一篇文章把想法先讲完好.

本文是我关于 "复杂多轮对话机器人" 的相关思考和实现思路. 综合而言有三点:


-   ```语音OS```(语音操作界面)是对话机器人的未来方向之一, 或将领衔下一轮的交互革命
-   ```复杂多轮对话```问题是现阶段对话机器人短板, 关键在于定义哪些功能点 ( features )
-   从```对话OS```角度看, 并非只有机器学习一条路, 工程化策略也有许多相对优势


CommuneChatbot 项目本身就是本着这三点思考而创建, 开发的.
它首先承载了对话机器人的框架功能, 用来整合各个组件, 包括:

-   平台接入 (即时通讯, 智能音箱, 等)
-   输入转换模块 (例如语音转文字)
-   语义理解模块 (NLU, 用于解析语义)
-   多轮对话管理模块
-   输出转换模块 (例如i18n, 文字转语音等)

但它最核心的地方在于 ```多轮对话管理模块```.

然而这个定义似乎不容易被人理解.
在和人介绍这个项目的过程中, 许多没接触过对话机器人的工程师, 都觉得对话管理很容易实现,
或者说不重要, 不算 "从零到一". 或者觉得工程框架 "谁都能做出来, 无非就是..."

对待这类观点, 我目前只能说, 自己最初并没考虑开发一个对话机器人框架,
而是需要这样的框架让我可以开发各种设想的应用.
然而调研了市面上许多解决方案,
却没有发现一款满足需求的, 所以才有了自己开发的 CommuneChatbot.

这个项目在工程上花了许多心思, 大小技术细节有上百个, 但工程上的东西另搞一套都很容易,
算不得从零到一.
但项目核心方案的设计过程, 对我而言是一个从零到一的技术突破, 是完全原创, 没有任何借鉴对象的. 因此想用这篇文章记录下来.

至于正确与否, 行业未来的发展会给出一个明确的论断. 我此时的观点仅供参考.


### CommuneChatbot 接下来的计划

[CommuneChatbot](https://github.com/thirdgerb/chatbot) 项目目前上线了demo, 在同名公众号测试. 正在开发它的第一个正式版 ( v0.1 ). 目标是有完整的说明文档, 并在生产环境中可用, 有具体的应用示例.

目前正在考虑开发的功能:

-   使用一款和 swoole 协程IO 结合得更好的框架作为开发平台
-   为初步使用者, 提供一个基本可用的后台
-   除rasa外, 接入国内的 NLU 服务商, 例如百度UNIT, 讯飞等
-   接入一款智能音箱平台, 如小度, 小爱同学, 天猫精灵
-   整合到树莓派开源智能音箱, 作为语音OS的中枢.

目前的应用设想有:

-   vbot : 提供微信机器人的开发功能
-   智能音箱应用 : 开发基于复杂多轮对话的智能音箱应用
-   FAQ : 能接入各种IM, 语音平台的 FAQ, 有完整多轮对话流程和管理后台
-   知识图谱Wiki : 基于知识图谱, 在多轮对话中编辑和查找内容的wiki

如果有意见与建议, 请不吝赐教. 邮箱 thirdgerb@gmail.com